#include "PrecompiledHeaders.h"
#include "Mesh.h"
#include "Plane.h"
#include "MeshOctreeClasses.h"
#include "Textile.h"
#include "TexGen.h"

using namespace TexGen;

auto LessPairDoubleXYZ = [](std::pair<double, XYZ> x, std::pair<double, XYZ> y) { return x.first < y.first; };

bool CMesh::AddElement(ELEMENT_TYPE Type, const vector<int> &Indices)
{
	if (Type < 0 || Type >= NUM_ELEMENT_TYPES)
	{
		TGERROR("Tried to add element of invalid type: " << Type);
		return false;
	}
	if ((int)Indices.size() != GetNumNodes(Type) && Type != CMesh::POLYGON )
	{
		TGERROR("Tried to add element of type " << Type << " with invalid number of indices: " << Indices.size());
		return false;
	}
	if ( Type == CMesh::POLYGON && *(Indices.begin()) != *(Indices.end()-1) )
	{
		TGERROR("Tried to add unclosed POLYGON to mesh" );
		return false;
	}
	m_Indices[Type].insert(m_Indices[Type].end(), Indices.begin(), Indices.end());
	return true;
}
vector<XYZ>::const_iterator CMesh::NodesBegin() const
{
	return m_Nodes.begin();
}
vector<XYZ>::iterator CMesh::NodesBegin()
{
	return m_Nodes.begin();
}
void CMesh::AddOrCancel(list<pair<int, int> > &EdgeStack, pair<int, int> Edge)
{
	list<pair<int, int> >::iterator FindResult;
	FindResult = find(EdgeStack.begin(), EdgeStack.end(), Edge);
	if (FindResult != EdgeStack.end())
	{
		EdgeStack.erase(FindResult);
		return;
	}
	FindResult = find(EdgeStack.begin(), EdgeStack.end(), pair<int, int>(Edge.second, Edge.first));
	if (FindResult != EdgeStack.end())
	{
		EdgeStack.erase(FindResult);
		return;
	}
	EdgeStack.push_back(Edge);
}
void CMesh::SetNumNodes(int NumNodes)
{
	m_Nodes.resize(NumNodes);
}
bool CMesh::SaveToABAQUS(string Filename, const vector<POINT_INFO> *pElementInfo, bool bCreateStep, bool bCreateMaterial, int iElementType)
{
	AddExtensionIfMissing(Filename, ".inp");

	ofstream Output(Filename.c_str());

	if (!Output)
	{
		TGERROR("Unable to output mesh to ABAQUS file format, could not open file: " << Filename);
		return false;
	}

	TGLOG("Saving mesh data to " << Filename);

	Output << "*Heading" << endl;
	Output << "File generated by TexGen v" << TEXGEN.GetVersion() << endl;

	Output << "************" << endl;
	Output << "*** MESH ***" << endl;
	Output << "************" << endl;
	Output << "*Node" << endl;
	OutputNodes(Output, 1);

	int iStartIndex = 1;

	// Linear elements
	if (!m_Indices[TET].empty())
	{
		Output << "*Element, Type=C3D4" << endl;
		iStartIndex = OutputElements(Output, TET, iStartIndex, 1);
	}

	if (!m_Indices[WEDGE].empty())
	{
		Output << "*Element, Type=C3D6" << endl;
		// NOTE: The element ordering is different between ABAQUS and VTK...
		// and since the index ordering in this class is based on VTK we need
		// to reorder the elements :(. So we won't use the OutputElements function
		// in this case
//		iStartIndex = OutputElements(Output, WEDGE, iStartIndex, 1);
		int i1, i2, i3, i4, i5, i6;
		int iElementNumber = 0;
		list<int>::const_iterator itIndex;
		for (itIndex = m_Indices[WEDGE].begin(); itIndex != m_Indices[WEDGE].end(); ++iElementNumber)
		{
			i1 = *(itIndex++)+1;
			i2 = *(itIndex++)+1;
			i3 = *(itIndex++)+1;
			i4 = *(itIndex++)+1;
			i5 = *(itIndex++)+1;
			i6 = *(itIndex++)+1;
			Output << iElementNumber+iStartIndex
				<< ", " << i4 << ", " << i5 << ", " << i6
				<< ", " << i1 << ", " << i2 << ", " << i3
				<< endl;
		}
		iStartIndex += iElementNumber;
	}

	if (!m_Indices[HEX].empty())
	{
		if ( !iElementType )
		{
			Output << "*Element, Type=C3D8R" << endl;
		}
		else
		{
			Output << "*Element, Type=C3D8" << endl;
		}
		iStartIndex = OutputElements(Output, HEX, iStartIndex, 1);
	}

	// Quadratic elements
	if (!m_Indices[QUADRATIC_TET].empty())
	{
		Output << "*Element, Type=C3D10" << endl;
		iStartIndex = OutputElements(Output, QUADRATIC_TET, iStartIndex, 1);
	}

	// Shell elements
	if (!m_Indices[QUAD].empty())
	{
		Output << "*Element, Type=S4R" << endl;
		iStartIndex = OutputElements(Output, QUAD, iStartIndex, 1);
	}

	if (pElementInfo)
	{
		string OrientationsFilename = Filename;
		OrientationsFilename.replace(OrientationsFilename.end()-4, OrientationsFilename.end(), ".ori");
		ofstream OriOutput(OrientationsFilename.c_str());
		string ElementDataFilename = Filename;
		ElementDataFilename.replace(ElementDataFilename.end()-4, ElementDataFilename.end(), ".eld");
		ofstream DataOutput(ElementDataFilename.c_str());

		if (!OriOutput)
		{
			TGERROR("Unable to output orientations, could not open file: " << OrientationsFilename);
			return false;
		}
		if (!DataOutput)
		{
			TGERROR("Unable to output additional element data, could not open file: " << ElementDataFilename);
			return false;
		}

		TGLOG("Saving element orientations data to " << OrientationsFilename);
		TGLOG("Saving additional element data to " << ElementDataFilename);

		WriteOrientationsHeader( Output );
		Output << "*Distribution Table, Name=TexGenOrientationVectors" << endl;
		Output << "COORD3D,COORD3D" << endl;
		Output << "*Distribution, Location=Element, Table=TexGenOrientationVectors, Name=TexGenOrientationVectors, Input=" << StripPath(OrientationsFilename) << endl;
		Output << "*Orientation, Name=TexGenOrientations, Definition=coordinates" << endl;
		Output << "TexGenOrientationVectors" << endl;
		Output << "1, 0" << endl;

		// Default orientation
		WriteOrientationsHeader( OriOutput );
		OriOutput <<  ", 1.0, 0.0, 0.0,   0.0, 1.0, 0.0" << endl;

		int i;
		
		WriteElementsHeader( DataOutput );

		map<int, vector<int> > ElementSets;
		vector<POINT_INFO>::const_iterator itData;
		for (itData = pElementInfo->begin(), i=1; itData != pElementInfo->end(); ++itData, ++i)
		{
			if (itData->iYarnIndex != -1)
			{
				if ( GetLength(itData->Up ) )
				{
					XYZ Up = itData->Up;
					XYZ Dir = itData->Orientation;
				
					XYZ Perp = CrossProduct(Dir, Up);
					Normalise(Perp);
					OriOutput << i << ", " << Dir << ",   " << Perp << endl;
				}
				else
				{
					// Default orientation
					OriOutput << i << ", 1.0, 0.0, 0.0,   0.0, 1.0, 0.0" << endl;
				}
			}
			else
			{
				// Default orientation
				OriOutput << i << ", 1.0, 0.0, 0.0,   0.0, 1.0, 0.0" << endl;
			}
			DataOutput << i;
			DataOutput << ", " << itData->iYarnIndex;
			DataOutput << ", " << itData->Location;		// This counts as 2 DepVars
			DataOutput << ", " << itData->dVolumeFraction;
			DataOutput << ", " << itData->dSurfaceDistance;
			DataOutput << endl;
			ElementSets[itData->iYarnIndex].push_back(i);
		}

		// Output element sets
		Output << "********************" << endl;
		Output << "*** ELEMENT SETS ***" << endl;
		Output << "********************" << endl;
		Output << "** TexGen generates a number of element sets:" << endl;
		Output << "** All - Contains all elements" << endl;
		Output << "** Matrix - Contains all elements belonging to the matrix" << endl;
		Output << "** YarnX - Where X represents the yarn index" << endl;
		Output << "*ElSet, ElSet=All, Generate" << endl;
		Output << "1, " << GetNumElements() << ", 1" << endl;
		vector<int>::iterator itIndices;
		map<int, vector<int> >::iterator itElementSet;
		for (itElementSet = ElementSets.begin(); itElementSet != ElementSets.end(); ++itElementSet)
		{
			if (itElementSet->first == -1)
				Output << "*ElSet, ElSet=Matrix" << endl;
			else
				Output << "*ElSet, ElSet=Yarn" << itElementSet->first << endl;
			int iLinePos = 0;
			for (itIndices = itElementSet->second.begin(); itIndices != itElementSet->second.end(); ++itIndices)
			{
				if (iLinePos == 0)
				{
					// Do nothing...
				}
				else if (iLinePos < 16)
				{
					Output << ", ";
				}
				else
				{
					Output << endl;
					iLinePos = 0;
				}
				Output << *itIndices;
				++iLinePos;
			}
			Output << endl;
		}

		// Output materials, this is only here because it is necessary in order to associate
		// orientations and other things to the yarns. It just creates a linear elastic isotropic
		// material with young's modulus of 1.
		if (bCreateMaterial)
		{
			Output << "*****************" << endl;
			Output << "*** MATERIALS ***" << endl;
			Output << "*****************" << endl;
			Output << "*Material, Name=TexGenGenerated" << endl;
			Output << "*Elastic" << endl;
			Output << "1.0, 0.0" << endl;
			Output << "*DepVar" << endl;
			Output << "5" << endl;
	//		Output << "*Solid Section, ElSet=All, Material=TexGenGenerated, Orientation=TexGenOrientations" << endl;
	//		Output << "1.0," << endl;
			for (itElementSet = ElementSets.begin(); itElementSet != ElementSets.end(); ++itElementSet)
			{
				// Let's create 1 section definition for the matrix and each yarn so that it is easy
				// to apply different material properties to different yarns in ABAQUS CAE
				ostringstream SetName;
				if (itElementSet->first == -1)
				{
					SetName << "Matrix";
				}
				else
				{
					SetName << "Yarn" << itElementSet->first;
				}
				Output << "*Solid Section, ElSet=" << SetName.str() << ", Material=TexGenGenerated, Orientation=TexGenOrientations" << endl;
				Output << "1.0," << endl;
			}
			Output << "** Note: Additional element data are stored as a depvars:" << endl;
			Output << "** 1 - Yarn Index (-1 for matrix, first yarn starting at 0)" << endl;
			Output << "** 2/3 - Location (x and y cross-section coordinates of element relative to yarn centerline)" << endl;
			Output << "** 4 - Volume fraction" << endl;
			Output << "** 5 - Distance of element from the surface of the yarn (for yarn elements only, distance is negative)" << endl;
			Output << "*Initial Conditions, Type=Solution, Input=" << StripPath(ElementDataFilename) << endl;
		}

		if (bCreateStep)
		{
			Output << "************" << endl;
			Output << "*** STEP ***" << endl;
			Output << "************" << endl;
			Output << "*Step, Name=TexGenGenerated" << endl;
			Output << "*Static" << endl;
			Output << "*Output, Field, Variable=PRESELECT" << endl;
	//		Output << "*Output, History, Variable=PRESELECT" << endl;
			Output << "*Element Output" << endl;
			Output << "SDV" << endl;
			Output << "*Node Print" << endl;
			Output << "U" << endl;
			Output << "*End Step" << endl;
		}
	}

	return true;
}
bool CMesh::SaveToSCIRun(string Filename) 
{
	Filename = RemoveExtension( Filename, ".pts" );
	AddExtensionIfMissing(Filename, ".tri.pts");

	ofstream Output(Filename.c_str());

	if (!Output)
	{
		TGERROR("Unable to output mesh to SCIRun .pts file format, could not open file: " << Filename);
		return false;
	}

	TGLOG("Saving mesh data to " << Filename);

	
	OutputNodes(Output, 1, ",", true );

	int iStartIndex = 1;

	Filename = RemoveExtension( Filename, ".pts" );
	AddExtensionIfMissing( Filename, ".fac" );

	ofstream ElementOutput( Filename.c_str());

	if (!ElementOutput)
	{
		TGERROR("Unable to output mesh to SCIRun .fac file format, could not open file: " << Filename);
		return false;
	}

	TGLOG("Saving mesh data to " << Filename);

	ConvertQuadstoTriangles();

	// Tri elements
	if (!m_Indices[TRI].empty())
	{
		iStartIndex = OutputElements(ElementOutput, TRI, iStartIndex, 1, ", ", true);
	}
	return true;
}
void CMesh::MeshConvexHull()
{
	// Algorithm and code taken from: (the incremental method is implemented since it seems to be
	// the easiest to implement and quite robust, I tried to implement the gift wrap method however
	// it doesn't seem as robust, problems occur when points are collinear and/or coplanar)
	// http://www.cse.unsw.edu.au/~lambert/java/3d/hull.html
	// http://www.cse.unsw.edu.au/~lambert/java/3d/incremental.html
	// http://www.cse.unsw.edu.au/~lambert/java/3d/source/Incremental.java
	const double TOL = 1e-7;

	list<pair<int, int> > EdgeStack;
	list<pair<int, int> >::iterator itEdge;

	MergeNodes();

	int i;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		m_Indices[i].clear();
	}

	if (m_Nodes.size() < 3)
		return;

	list<int> &TriangleIndices = m_Indices[TRI];
	// Generate a list of triangle normals
	list<PLANE> TrianglePlanes;
	PLANE Plane;
	XYZ P1, P2, P3, P;

	// Find the first set of 3 points that are not collinear to create a triangle
	for (i=0; i+2<(int)m_Nodes.size(); ++i)
	{
		P1 = m_Nodes[i+0];
		P2 = m_Nodes[i+1];
		P3 = m_Nodes[i+2];
		Plane.Normal = CrossProduct(P2 - P1, P3 - P1);
		if (GetLengthSquared(Plane.Normal) > TOL*TOL)
		{
			break;
		}
	}
	if (i+2 == (int)m_Nodes.size())
	{
		TGERROR("Unable to create convex hull, all points are collinear");
		assert(false);
		return;
	}

	TriangleIndices.push_back(i+0);
	TriangleIndices.push_back(i+1);
	TriangleIndices.push_back(i+2);
	Normalise(Plane.Normal);
	Plane.d = DotProduct(Plane.Normal, P1);
	TrianglePlanes.push_back(Plane);

	TriangleIndices.push_back(i+0);
	TriangleIndices.push_back(i+2);
	TriangleIndices.push_back(i+1);
	Plane.Normal = -Plane.Normal;
	Plane.d = -Plane.d;
	TrianglePlanes.push_back(Plane);

	list<int>::iterator itIter, itTriStart;
	list<PLANE>::iterator itPlane;
	int i1, i2, i3;
	bool bFacesAdded;
	// This loop will be iterated until no more faces are added, this is necessary when
	// we have more than 3 nodes that are coplanar. If not some nodes will be missed.
	do
	{
		bFacesAdded = false;
		for (i=0; i<(int)m_Nodes.size(); ++i)
		{
			P = m_Nodes[i];
			// Delete faces that this vertex can see
			for (itIter = TriangleIndices.begin(), itPlane = TrianglePlanes.begin(); itIter != TriangleIndices.end(); )
			{
				itTriStart = itIter;
				i1 = *(itIter++);
				i2 = *(itIter++);
				i3 = *(itIter++);
				// If the vertex can see the plane (with a tolerance) we don't want to remove
				// triangles that are in the same place as the vertex or the algorithm will fail.
				if (DotProduct(itPlane->Normal, P) > itPlane->d+TOL)
				{
					// If the edge already exist in the edge stack then it should cancel with it
					// (remove the edge rather than adding it) otherwise add the edge.
					AddOrCancel(EdgeStack, pair<int, int>(i1, i2));
					AddOrCancel(EdgeStack, pair<int, int>(i2, i3));
					AddOrCancel(EdgeStack, pair<int, int>(i3, i1));
					// Delete the triangle
					itIter = TriangleIndices.erase(itTriStart, itIter);
					itPlane = TrianglePlanes.erase(itPlane);
				}
				else
					++itPlane;
			}
			// Create new triangles and calculate the planes of the new triangle.
			// Not only is it an optimisation to calculate the triangle planes only once
			// it is also for consitency.
			for (itEdge = EdgeStack.begin(); itEdge != EdgeStack.end(); ++itEdge)
			{
				i1 = itEdge->first;
				i2 = itEdge->second;
				i3 = i;
				TriangleIndices.push_back(i1);
				TriangleIndices.push_back(i2);
				TriangleIndices.push_back(i3);
				P1 = m_Nodes[i1];
				P2 = m_Nodes[i2];
				P3 = m_Nodes[i3];
				Plane.Normal = CrossProduct(P2 - P1, P3 - P1);
				Normalise(Plane.Normal);
				Plane.d = DotProduct(Plane.Normal, P1);
				TrianglePlanes.push_back(Plane);
				bFacesAdded = true;
			}
			EdgeStack.clear();
		}
	} while (bFacesAdded);
}
void CMesh::CopySelfToRange(XYZ Vector, int iLowerLimit, int iUpperLimit)
{
	CMesh Original = *this;
	Clear();
	int i;
	for (i=iLowerLimit; i<=iUpperLimit; ++i)
	{
		InsertMesh(Original, i*Vector);
	}
}
vector<XYZ> CMesh::GetElementCenters() const
{
	TGLOG("Get Element Centres");
	vector<XYZ> ElementCenters;
	int i, j, iNumNodes;
	list<int>::const_iterator itIndex;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		iNumNodes = GetNumNodes((ELEMENT_TYPE)i);
		if ( iNumNodes != -1 )
		{
			for (itIndex = m_Indices[i].begin(); itIndex != m_Indices[i].end(); )
			{
				XYZ Center;
				for (j=0; j<iNumNodes; ++j)
				{
					Center += m_Nodes[*itIndex];
					++itIndex;
				}
				Center /= iNumNodes;
				ElementCenters.push_back(Center);
			}
		}
	}
	return ElementCenters;
}
void CMesh::ConvertElementListToVector( ELEMENT_TYPE ElementType, vector<int> &Indices )
{
	assert(ElementType >= 0 && ElementType < NUM_ELEMENT_TYPES);

	Indices.insert( Indices.begin(), m_Indices[ElementType].begin(), m_Indices[ElementType].end() );
}
void CMesh::Clear()
{
	m_Nodes.clear();
	int i;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		m_Indices[i].clear();
	}
/*	map<ELEMENT_TYPE, list<int> >::iterator itType;
	for (itType = m_Indices.begin(); itType != m_Indices.end(); ++itType)
	{
		itType->second.clear();
	}*/
}
const int CMesh::AddNode(XYZ Node)
{
	m_Nodes.push_back(Node);
	return (int)m_Nodes.size()-1;
}
void CMesh::SetNode(int iIndex, XYZ Node)
{
	assert(iIndex >= 0 && iIndex<(int)m_Nodes.size());
	m_Nodes[iIndex] = Node; 
} 
const vector<XYZ>& CMesh::GetNodes() const
{
	return m_Nodes;
}

vector<XYZ>& CMesh::GetNodes()
{
	return m_Nodes;
}
vector<XYZ>::const_iterator CMesh::NodesEnd() const
{
	return m_Nodes.end();
}
vector<XYZ>::iterator CMesh::NodesEnd()
{
	return m_Nodes.end();
}
const list<int>& CMesh::GetIndices(ELEMENT_TYPE ElemType) const
{
	assert(ElemType >= 0 && ElemType < NUM_ELEMENT_TYPES);
	return m_Indices[ElemType];
}

list<int>& CMesh::GetIndices(ELEMENT_TYPE ElemType)
{
	assert(ElemType >= 0 && ElemType < NUM_ELEMENT_TYPES);
	return m_Indices[ElemType];
}

const bool CMesh::NodesEmpty() const
{
	return m_Nodes.empty();
}
int CMesh::GetNumNodes() const
{
	return (int)m_Nodes.size();
}
int CMesh::IntersectLine(const XYZ &P1, const XYZ &P2, vector<pair<double, XYZ> > &IntersectionPoints, pair<bool, bool> TrimResults, bool bForceFind/*, const CElementsOctree *pOctree*/) const
{
	int i;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		if (i != TRI && !m_Indices[i].empty())
		{
			TGERROR("Warning: IntersectLine only works for triangle mesh, mesh contains other element types");
			break;
		}
	}

	IntersectionPoints.clear();

	XYZ T1, T2, T3;
	XYZ Normal, Intersection;
	double dU;
	const double dTolerance = 1e-9;
/*	if (pOctree && pOctree->GetOctree())
	{
		list<vector<int> > Elements;
		list<vector<int> >::iterator itIter;

		COctreeVisitorElementNearLine Visitor(P1, P2, Elements, TrimResults);

		pOctree->GetOctree()->visit(Visitor);

		for (itIter = Elements.begin(); itIter != Elements.end(); ++itIter)
		{
			T1 = m_Nodes[(*itIter)[0]];
			T2 = m_Nodes[(*itIter)[1]];
			T3 = m_Nodes[(*itIter)[2]];

			Normal = CrossProduct(T2-T1, T3-T1);
			Normalise(Normal);

			if (GetIntersectionLinePlane(P1, P2, T1, Normal, Intersection, &dU))
			{
				if (TrimResults.first && dU < 0)
					; // Do nothing
				else if(TrimResults.second && dU > 1)
					; // Do nothing
				else if (PointInsideTriangle(T1, T2, T3, Intersection, Normal))
				{
					IntersectionPoints.push_back(pair<double, XYZ>(dU, Normal));
				}
			}
		}
	}
	else
	{*/
		bool bFirst = true;
		double dMin;
		double dAccuracy;
		double dBestU;
		XYZ BestNormal;

		const list<int> &TriangleIndices = m_Indices[TRI];
		list<int>::const_iterator itIter;
		for (itIter = TriangleIndices.begin(); itIter != TriangleIndices.end(); )
		{
			T1 = m_Nodes[*(itIter++)];
			T2 = m_Nodes[*(itIter++)];
			T3 = m_Nodes[*(itIter++)];

			Normal = CrossProduct(T2-T1, T3-T1);
			if (Normal)
			{
				Normalise(Normal);

				if (GetIntersectionLinePlane(P1, P2, T1, Normal, Intersection, &dU))
				{
					if (TrimResults.first && dU < 0)
						continue; // Do nothing
					if(TrimResults.second && dU > 1)
						continue; // Do nothing
					dMin = PointInsideTriangleAccuracy(T1, T2, T3, Intersection, Normal);
					if (dMin >= -dTolerance)
					{
						IntersectionPoints.push_back(pair<double, XYZ>(dU, Normal));
					}
					if (bFirst || dMin > dAccuracy)
					{
						dAccuracy = dMin;
						bFirst = false;
						dBestU = dU;
						BestNormal = Normal;
					}
/*					if (PointInsideTriangle(T1, T2, T3, Intersection, Normal))
					{
						IntersectionPoints.push_back(pair<double, XYZ>(dU, Normal));
					}*/
				}
			}
		}
//	}

	if (bForceFind && IntersectionPoints.empty())
	{
		IntersectionPoints.push_back(pair<double, XYZ>(dBestU, BestNormal));
	}

	//sort(IntersectionPoints.begin(), IntersectionPoints.end(), LessPairDoubleXYZ());
	sort(IntersectionPoints.begin(), IntersectionPoints.end(), LessPairDoubleXYZ);

	return IntersectionPoints.size();
}
int CMesh::GetNumElements(ELEMENT_TYPE Type) const
{
	assert(Type >= 0 && Type < NUM_ELEMENT_TYPES);
	return m_Indices[Type].size()/GetNumNodes(Type);
}
int CMesh::GetNumElements() const
{
	int iNumElements = 0;
	int i;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		if ( (ELEMENT_TYPE)i != CMesh::POLYGON )
			iNumElements += GetNumElements((ELEMENT_TYPE)i);
	}
	return iNumElements;
}
double CMesh::CalculateVolume() const
{
	int i;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		if (i != TRI && !m_Indices[i].empty())
		{
			CMesh TriMesh(*this);
			TriMesh.ConvertToTriangleMesh();  // Converts whole mesh to triangle not just current element type
			return TriMesh.CalculateVolume(); // Which is why can return after CalculateVolume
		}
	}

	double dVolume = 0;
	// Code from http://www.gamedev.net/reference/articles/article2247.asp
	const list<int> &TriangleIndices = m_Indices[TRI];
	XYZ P1, P2, P3;
	list<int>::const_iterator itIter;
	for (itIter = TriangleIndices.begin(); itIter != TriangleIndices.end(); )
	{
		P1 = m_Nodes[*(itIter++)];
		P2 = m_Nodes[*(itIter++)];
		P3 = m_Nodes[*(itIter++)];

		dVolume += ((P2.y-P1.y)*(P3.z-P1.z)-(P2.z-P1.z)*(P3.y-P1.y)) * (P1.x+P2.x+P3.x);
	}

	return dVolume / 6;
}
const XYZ& CMesh::GetNode(int iIndex) const
{
	return m_Nodes[iIndex];
}

bool CMesh::SaveToVTK(string Filename, const vector<CMeshDataBase*> *pMeshData) const
{
	AddExtensionIfMissing(Filename, ".vtu");

	TiXmlDocument doc;
	TiXmlDeclaration decl("1.0", "", "");
	doc.InsertEndChild(decl);
	TiXmlElement VTKFile("VTKFile");
	{
		VTKFile.SetAttribute("type", "UnstructuredGrid");
		VTKFile.SetAttribute("version", "0.1");
		VTKFile.SetAttribute("byte_order", "LittleEndian");
		TiXmlElement UnstructuredGrid("UnstructuredGrid");
		{
			TiXmlElement Piece("Piece");
			{
				TiXmlElement Points("Points");
				int iNumPoints = FillVTKPointData(Points);
				Piece.InsertEndChild(Points);

				TiXmlElement Cells("Cells");
				int iNumCells = FillVTKCellData(Cells);
				Piece.InsertEndChild(Cells);

				if (pMeshData)
				{
					TiXmlElement PointData("PointData");
					TiXmlElement CellData("CellData");
					vector<CMeshDataBase*>::const_iterator itData;
					for (itData = pMeshData->begin(); itData != pMeshData->end(); ++itData)
					{
						if ((*itData)->m_DataType == CMeshDataBase::NODE)
							(*itData)->InsertVTKData(PointData);
						else
							(*itData)->InsertVTKData(CellData);
					}
					TGLOG("Finished iterator");
					Piece.InsertEndChild(PointData);
					Piece.InsertEndChild(CellData);
					TGLOG("End InsertVTKData");
				}

				Piece.SetAttribute("NumberOfPoints", stringify(iNumPoints));
				Piece.SetAttribute("NumberOfCells", stringify(iNumCells));
			}
			UnstructuredGrid.InsertEndChild(Piece);
		}
		VTKFile.InsertEndChild(UnstructuredGrid);
	}

	doc.InsertEndChild(VTKFile);
	TGLOG("Return call SaveFile");
	return doc.SaveFile(Filename);
}
int CMesh::FillVTKCellData(TiXmlElement &Cells) const
{
	TGLOG("FillVTKCellData");
	ostringstream ConnectivityData;
	ostringstream OffsetsData;
	ostringstream TypesData;

	int i, iOffset = 0;
	int iTotalNumCells = 0;
	list<int>::const_iterator itIndex;
	int j;
	for (j = 0; j < NUM_ELEMENT_TYPES; ++j)
	{
		int iVTKType = 0;
		switch (j)
		{
		case TRI:
			iVTKType = 5;
			break;
		case QUAD:
			iVTKType = 9;
			break;
		case TET:
			iVTKType = 10;
			break;
		case WEDGE:
			iVTKType = 13;
			break;
		case PYRAMID:
			iVTKType = 14;
			break;
		case HEX:
			iVTKType = 12;
			break;
		case LINE:
			iVTKType = 3;
			break;
		case POLYLINE:
			iVTKType = 4;
			break;
		case QUADRATIC_TET:
			iVTKType = 24;
			break;
		}
		if (iVTKType != 0)
		{
			int iNumNodesPerElement = GetNumNodes((ELEMENT_TYPE)j);
			int iNumElements = m_Indices[j].size()/iNumNodesPerElement;
			for (itIndex = m_Indices[j].begin(), i=0; itIndex != m_Indices[j].end(); ++itIndex, ++i)
			{
				ConnectivityData << *itIndex << " ";
			}
			for (i=0; i<iNumElements; ++i)
			{
				TypesData << iVTKType << " ";
			}
			for (i=0; i<iNumElements; ++i)
			{
				iOffset += iNumNodesPerElement;
				OffsetsData << iOffset << " ";
			}
			iTotalNumCells += iNumElements;
		}
	}


	TiXmlElement Connectivity("DataArray");
	{
		Connectivity.SetAttribute("type", "Int32");
		Connectivity.SetAttribute("Name", "connectivity");
		Connectivity.SetAttribute("format", "ascii");
		Connectivity.InsertEndChild(TiXmlText(ConnectivityData.str()));
	}
	Cells.InsertEndChild(Connectivity);

	TiXmlElement Offsets("DataArray");
	{
		Offsets.SetAttribute("type", "Int32");
		Offsets.SetAttribute("Name", "offsets");
		Offsets.SetAttribute("format", "ascii");
		Offsets.InsertEndChild(TiXmlText(OffsetsData.str()));
	}
	Cells.InsertEndChild(Offsets);

	TiXmlElement Types("DataArray");
	{
		Types.SetAttribute("type", "Int32");
		Types.SetAttribute("Name", "types");
		Types.SetAttribute("format", "ascii");
		Types.InsertEndChild(TiXmlText(TypesData.str()));
	}
	Cells.InsertEndChild(Types);
	TGLOG("return");
	return iTotalNumCells;
}
vector<XYZ>::iterator CMesh::DeleteNode(vector<XYZ>::iterator it)
{
	return m_Nodes.erase(it);
}
vector<XYZ> CMesh::GetElementCenters( ELEMENT_TYPE type )
{
	vector<XYZ> ElementCentres;
	int iNumNodes = GetNumNodes(type);
	list<int>::const_iterator itIndex;
	for ( itIndex = m_Indices[type].begin(); itIndex != m_Indices[type].end(); )
	{
		XYZ Centre;
		for (int i=0; i<iNumNodes; ++i)
		{
			Centre += m_Nodes[*itIndex];
			++itIndex;
		}
		Centre /= iNumNodes;
		ElementCentres.push_back(Centre);
	}
	return ElementCentres;
}
int CMesh::OutputNodes(ostream &Output, int iStartIndex, string Seperator, bool bSCIRun) const
{
	int iNodeIndex;
	vector<XYZ>::const_iterator itNode;

	if ( bSCIRun )
		Output << m_Nodes.size() << endl;

	for (itNode = m_Nodes.begin(), iNodeIndex=0; itNode != m_Nodes.end(); ++itNode, ++iNodeIndex)
	{
		if (iStartIndex >= 0 && !bSCIRun)
			Output << iNodeIndex+iStartIndex << Seperator;
		Output << *itNode << endl;
	}
	return iNodeIndex+iStartIndex;
}
int CMesh::OutputElements(ostream &Output, CMesh::ELEMENT_TYPE ElementType, int iStartIndex, int iIndexOffset, string Seperator, bool bSCIRun) const
{
	assert(ElementType >= 0 && ElementType < NUM_ELEMENT_TYPES);
	int i;
	int iElementNumber = 0;
	list<int>::const_iterator itIndex;

	if ( bSCIRun )
		Output << m_Indices[ElementType].size()/GetNumNodes(ElementType) << endl;
	for (itIndex = m_Indices[ElementType].begin(); itIndex != m_Indices[ElementType].end(); ++iElementNumber)
	{
		if (iStartIndex >= 0 && !bSCIRun)
			Output << iElementNumber+iStartIndex << Seperator;
		for (i=0; i<GetNumNodes(ElementType); ++i, ++itIndex)
		{
			if (i>0)
				Output << Seperator;
			Output << (*itIndex)+iIndexOffset;
		}
		Output << endl;
	}
	return iElementNumber+iStartIndex;
}
int CMesh::FillVTKPointData(TiXmlElement &Points) const
{
	TGLOG("FillVTKPointData");
	ostringstream PointsData;
	vector<XYZ>::const_iterator itNode;
	for (itNode = m_Nodes.begin(); itNode != m_Nodes.end(); ++itNode)
	{
		PointsData << itNode->x << " " << itNode->y << " " << itNode->z << " ";
	}

	TiXmlElement DataArray("DataArray");
	{
		DataArray.SetAttribute("type", "Float32");
		DataArray.SetAttribute("NumberOfComponents", "3");
		DataArray.SetAttribute("format", "ascii");
		DataArray.InsertEndChild(TiXmlText(PointsData.str()));
	}
	Points.InsertEndChild(DataArray);
	TGLOG("return");
	return m_Nodes.size();
}
void CMesh::GetNodeElementReferences(vector<vector<int*> > &References)
{
	References.clear();
	References.resize(m_Nodes.size());
	int i;
	list<int>::iterator itIndex;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		for (itIndex = m_Indices[i].begin(); itIndex != m_Indices[i].end(); ++itIndex)
		{
			References[*itIndex].push_back(&(*itIndex));
		}
	}
}
int CMesh::CountInvertedElements() const
{
	int i;
	int iNumInvertedElements = 0;
	for (i = 0; i < NUM_ELEMENT_TYPES; ++i)
	{
		iNumInvertedElements += CountInvertedElements((ELEMENT_TYPE)i);
	}
	return iNumInvertedElements;
}

int CMesh::CountInvertedElements(ELEMENT_TYPE ElementType) const
{
	if (ElementType != TET && ElementType != PYRAMID && ElementType != WEDGE)
	{
		return 0;
	}
	list<int>::const_iterator itIter;
	int i, iNumInvertedElements = 0;
	CMesh CopiedMesh;
	CopiedMesh.m_Nodes = m_Nodes;
	const list<int> &Indices = m_Indices[ElementType];
	int iNumNodes = GetNumNodes(ElementType);
	for (itIter = Indices.begin(); itIter != Indices.end(); )
	{
		CopiedMesh.m_Indices[ElementType].clear();
		for (i=0; i<iNumNodes; ++i)
		{
			CopiedMesh.m_Indices[ElementType].push_back(*(itIter++));
		}
		if (CopiedMesh.CalculateVolume() < 0)
		{
			++iNumInvertedElements;
		}
	}
	return iNumInvertedElements;
}